assert(isfolder and makefolder, "Unable to create folder")
local _xpcall, _pcall, _task, _math = xpcall, pcall, task, math

if not isfolder("MIDI") then
    makefolder("MIDI")
    local ok, content = _pcall(game.HttpGetAsync, game, "https://github.com/Ukrubojvo/api/raw/refs/heads/main/Summer.mid")
    if ok and content then
        writefile("./MIDI/Summer.mid", content)
    end
end

if not shared.AntiLuaLoading then
    shared.AntiLuaLoading = true
else
    return "Already Loaded"
end

local run = function(func)
    _xpcall(func, function(err)
        shared.AntiLuaLoading = false
        warn(err)
    end)
end

local WindUI
run(function()
    local ok, res = _pcall(function() return require("./src/Init") end)
    if ok and res then
        WindUI = res
    else
        local ok2, content = _pcall(game.HttpGetAsync, game, "https://github.com/Footagesus/WindUI/releases/latest/download/main.lua")
        if ok2 and content then
            local ok3, loaded = _pcall(loadstring, content)
            if ok3 and loaded then
                WindUI = loaded()
            end
        end
    end
end)

local function missing(t, f, fallback)
    if type(f) == t then return f end
    return fallback
end

local cloneref = missing("function", cloneref, function(...) return ... end)

local Services = setmetatable({}, {
    __index = function(self, name)
        local ok, service = _pcall(game.GetService, game, name)
        if ok and service then
            self[name] = cloneref(service)
            return self[name]
        end
        return nil
    end
})

local game = workspace.Parent
local RunService = Services.RunService
local Vim = Services.VirtualInputManager
local Uis = Services.UserInputManager
local Players = Services.Players
local Player = Players and Players.LocalPlayer

local ProtectGui = protectgui or (syn and syn.protect_gui) or function() end
local GuiParent = (gethui and gethui()) or (Player and Player.PlayerGui)

local KeyMap = {
    [21] = {keycode = Enum.KeyCode.One, ctrl = true}, [22] = {keycode = Enum.KeyCode.Two, ctrl = true},
    [23] = {keycode = Enum.KeyCode.Three, ctrl = true}, [24] = {keycode = Enum.KeyCode.Four, ctrl = true},
    [25] = {keycode = Enum.KeyCode.Five, ctrl = true}, [26] = {keycode = Enum.KeyCode.Six, ctrl = true},
    [27] = {keycode = Enum.KeyCode.Seven, ctrl = true}, [28] = {keycode = Enum.KeyCode.Eight, ctrl = true},
    [29] = {keycode = Enum.KeyCode.Nine, ctrl = true}, [30] = {keycode = Enum.KeyCode.Zero, ctrl = true},
    [31] = {keycode = Enum.KeyCode.Q, ctrl = true}, [32] = {keycode = Enum.KeyCode.W, ctrl = true},
    [33] = {keycode = Enum.KeyCode.E, ctrl = true}, [34] = {keycode = Enum.KeyCode.R, ctrl = true},
    [35] = {keycode = Enum.KeyCode.T, ctrl = true}, [36] = {keycode = Enum.KeyCode.One, shift = false},
    [37] = {keycode = Enum.KeyCode.One, shift = true}, [38] = {keycode = Enum.KeyCode.Two, shift = false},
    [39] = {keycode = Enum.KeyCode.Two, shift = true}, [40] = {keycode = Enum.KeyCode.Three, shift = false},
    [41] = {keycode = Enum.KeyCode.Four, shift = false}, [42] = {keycode = Enum.KeyCode.Four, shift = true},
    [43] = {keycode = Enum.KeyCode.Five, shift = false}, [44] = {keycode = Enum.KeyCode.Five, shift = true},
    [45] = {keycode = Enum.KeyCode.Six, shift = false}, [46] = {keycode = Enum.KeyCode.Six, shift = true},
    [47] = {keycode = Enum.KeyCode.Seven, shift = false}, [48] = {keycode = Enum.KeyCode.Eight, shift = false},
    [49] = {keycode = Enum.KeyCode.Eight, shift = true}, [50] = {keycode = Enum.KeyCode.Nine, shift = false},
    [51] = {keycode = Enum.KeyCode.Nine, shift = true}, [52] = {keycode = Enum.KeyCode.Zero, shift = false},
    [53] = {keycode = Enum.KeyCode.Q, shift = false}, [54] = {keycode = Enum.KeyCode.Q, shift = true},
    [55] = {keycode = Enum.KeyCode.W, shift = false}, [56] = {keycode = Enum.KeyCode.W, shift = true},
    [57] = {keycode = Enum.KeyCode.E, shift = false}, [58] = {keycode = Enum.KeyCode.E, shift = true},
    [59] = {keycode = Enum.KeyCode.R, shift = false}, [60] = {keycode = Enum.KeyCode.T, shift = false},
    [61] = {keycode = Enum.KeyCode.T, shift = true}, [62] = {keycode = Enum.KeyCode.Y, shift = false},
    [63] = {keycode = Enum.KeyCode.Y, shift = true}, [64] = {keycode = Enum.KeyCode.U, shift = false},
    [65] = {keycode = Enum.KeyCode.I, shift = false}, [66] = {keycode = Enum.KeyCode.I, shift = true},
    [67] = {keycode = Enum.KeyCode.O, shift = false}, [68] = {keycode = Enum.KeyCode.O, shift = true},
    [69] = {keycode = Enum.KeyCode.P, shift = false}, [70] = {keycode = Enum.KeyCode.P, shift = true},
    [71] = {keycode = Enum.KeyCode.A, shift = false}, [72] = {keycode = Enum.KeyCode.S, shift = false},
    [73] = {keycode = Enum.KeyCode.S, shift = true}, [74] = {keycode = Enum.KeyCode.D, shift = false},
    [75] = {keycode = Enum.KeyCode.D, shift = true}, [76] = {keycode = Enum.KeyCode.F, shift = false},
    [77] = {keycode = Enum.KeyCode.G, shift = false}, [78] = {keycode = Enum.KeyCode.G, shift = true},
    [79] = {keycode = Enum.KeyCode.H, shift = false}, [80] = {keycode = Enum.KeyCode.H, shift = true},
    [81] = {keycode = Enum.KeyCode.J, shift = false}, [82] = {keycode = Enum.KeyCode.J, shift = true},
    [83] = {keycode = Enum.KeyCode.K, shift = false}, [84] = {keycode = Enum.KeyCode.L, shift = false},
    [85] = {keycode = Enum.KeyCode.L, shift = true}, [86] = {keycode = Enum.KeyCode.Z, shift = false},
    [87] = {keycode = Enum.KeyCode.Z, shift = true}, [88] = {keycode = Enum.KeyCode.X, shift = false},
    [89] = {keycode = Enum.KeyCode.C, shift = false}, [90] = {keycode = Enum.KeyCode.C, shift = true},
    [91] = {keycode = Enum.KeyCode.V, shift = false}, [92] = {keycode = Enum.KeyCode.V, shift = true},
    [93] = {keycode = Enum.KeyCode.B, shift = false}, [94] = {keycode = Enum.KeyCode.B, shift = true},
    [95] = {keycode = Enum.KeyCode.N, shift = false}, [96] = {keycode = Enum.KeyCode.M, shift = false},
    [97] = {keycode = Enum.KeyCode.M, shift = true}, [98] = {keycode = Enum.KeyCode.U, ctrl = true},
    [99] = {keycode = Enum.KeyCode.I, ctrl = true}, [100] = {keycode = Enum.KeyCode.O, ctrl = true},
    [101] = {keycode = Enum.KeyCode.P, ctrl = true}, [102] = {keycode = Enum.KeyCode.A, ctrl = true},
    [103] = {keycode = Enum.KeyCode.S, ctrl = true}, [104] = {keycode = Enum.KeyCode.D, ctrl = true},
    [105] = {keycode = Enum.KeyCode.F, ctrl = true}, [106] = {keycode = Enum.KeyCode.G, ctrl = true},
    [107] = {keycode = Enum.KeyCode.H, ctrl = true}, [108] = {keycode = Enum.KeyCode.J, ctrl = true}
}

local Events = {}
local TempoEvents = {}
local Sustain = false
local Key88Enabled = true
local AutoSustainEnabled = true
local NoNoteOffEnabled = false
local RandomNoteEnabled = false
local DeblackEnabled = false
local DeblackLevel = 65
local Shift = false
local Ctrl = false
local ActiveNotes = {}
local StartTime = 0
local NextEventIndex = 1
local Paused = false
local PausePosition = 0
local TotalDuration = 0
local MidiFiles = {}
local PlaybackSpeed = 1.0
local MidiLoaded = false
local IsLoading = false
local PlayedSliderRef
local CleanupConnection

local MaxEvents = 500000
local MaxFileSize = 10 * 1024 * 1024
local DebounceTime = 0.28
local MaxParseTime = 30

local FolderName = "MIDI"
if not isfolder(FolderName) then makefolder(FolderName) end

local IgnorePlayedSliderCallback = false
local IgnoreSpeedSliderCallback = false

local function ReadVarInt(data, offset)
    local value = 0
    local bytesRead = 0
    local maxBytes = 4
    
    while bytesRead < maxBytes do
        local byte = string.byte(data, offset + bytesRead)
        if not byte then break end
        bytesRead = bytesRead + 1
        value = bit32.bor(bit32.lshift(value, 7), bit32.band(byte, 0x7F))
        if bit32.band(byte, 0x80) == 0 then break end
    end
    return value, bytesRead
end

local function CalculateRealtimePosition(ticks, ticksPerBeat, tempoChanges)
    if not ticks or not ticksPerBeat or ticksPerBeat == 0 then return 0 end
    
    local currentTick = 0
    local currentTimeMs = 0
    local currentTempo = 500000
    
    for i = 1, #tempoChanges do
        local tempoEvent = tempoChanges[i]
        if tempoEvent.tick <= ticks then
            local tickDiff = tempoEvent.tick - currentTick
            currentTimeMs = currentTimeMs + (tickDiff * currentTempo / 1000) / ticksPerBeat
            currentTick = tempoEvent.tick
            currentTempo = tempoEvent.tempo
        else
            break
        end
    end
    
    local remainingTicks = ticks - currentTick
    currentTimeMs = currentTimeMs + (remainingTicks * currentTempo / 1000) / ticksPerBeat
    
    return currentTimeMs / 1000
end

local function ApplyDeblack(parsedEvents)
    if not DeblackEnabled or not parsedEvents then
        return parsedEvents
    end

    local noteOnTimes = {}
    local lastNoteOff = {}
    local keepIndexes = {}
    local n = _math.min(#parsedEvents, MaxEvents)

    for i = 1, n do
        local note = parsedEvents[i]
        
        if not note or not note.abs_time or type(note.abs_time) ~= "number" then
            keepIndexes[i] = true
        elseif note.type == "control" then
            keepIndexes[i] = true
        elseif not note.channel or not note.note then
            keepIndexes[i] = true
        else
            local key = tostring(note.channel) .. ":" .. tostring(note.note)
            
            if note.vel and note.vel > 0 then
                local shouldIgnore = false
                local prevOff = lastNoteOff[key]
                
                if prevOff and prevOff.t and prevOff.v and type(prevOff.t) == "number" then
                    local dt = note.abs_time - prevOff.t
                    local velDiff = _math.abs(note.vel - prevOff.v)
                    if dt < 0.035 and velDiff < 7 then
                        shouldIgnore = true
                    end
                end

                if not shouldIgnore then
                    noteOnTimes[key] = { t = note.abs_time, idx = i, v = note.vel }
                end
            else
                local onData = noteOnTimes[key]
                if onData and onData.t and onData.v and type(onData.t) == "number" then
                    local dt = (note.abs_time - onData.t) * 1000
                    local vel = onData.v

                    lastNoteOff[key] = { t = note.abs_time, v = vel }
                    noteOnTimes[key] = nil

                    if not (vel <= DeblackLevel and dt < 20) then
                        keepIndexes[onData.idx] = true
                        keepIndexes[i] = true
                    end
                else
                    keepIndexes[i] = true
                end
            end
        end
    end

    local filteredEvents = {}
    local filteredCount = 0
    for i = 1, n do
        if keepIndexes[i] then
            filteredCount = filteredCount + 1
            filteredEvents[filteredCount] = parsedEvents[i]
        end
    end

    return filteredEvents
end

local function ParseMidiImproved(data)
    if not data or #data < 14 then
        return nil, "File too small"
    end
    
    if #data > MaxFileSize then
        return nil, "File too large (max 10MB)"
    end
    
    local parseStart = os.clock()
    local buffer = data
    local offset = 1
    local trackEndOffset = 0
    local isHeaderParsed = false
    local ticksPerBeat = 0
    local lastStatusByte = nil
    local trackTime = 0
    local noteOnStack = {}
    local parsedEvents = {}
    local tempoChanges = {{tick = 0, tempo = 500000}}
    local iterations = 0
    local maxIterations = 1000000

    while iterations < maxIterations do
        iterations = iterations + 1
        
        if os.clock() - parseStart > MaxParseTime then
            return nil, "Parse timeout"
        end
        
        if not isHeaderParsed then
            if #buffer < 14 then break end
            if string.sub(buffer, 1, 4) ~= 'MThd' then 
                return nil, "Invalid MIDI header"
            end
            ticksPerBeat = string.unpack(">H", buffer, 13)
            if ticksPerBeat == 0 then
                return nil, "Invalid ticks per beat"
            end
            offset = 15
            isHeaderParsed = true
        end

        if offset >= trackEndOffset then
            if #buffer - offset + 1 < 8 then break end
            if string.sub(buffer, offset, offset + 3) ~= 'MTrk' then break end
            offset = offset + 4
            local trackLength = string.unpack(">I4", buffer, offset)
            offset = offset + 4
            trackEndOffset = offset + trackLength - 1
            lastStatusByte = nil
            trackTime = 0
            noteOnStack = {}
        end

        if offset > trackEndOffset then break end

        local delta, deltaBytes = ReadVarInt(buffer, offset)
        offset = offset + deltaBytes
        trackTime = trackTime + delta

        local status
        local statusByte = string.byte(buffer, offset)
        if not statusByte then break end

        if bit32.band(statusByte, 0x80) ~= 0 then
            lastStatusByte = statusByte
            status = statusByte
            offset = offset + 1
        else
            if lastStatusByte == nil then break end
            status = lastStatusByte
        end

        local command = bit32.band(status, 0xF0)
        local channel = bit32.band(status, 0x0F)

        if #parsedEvents >= MaxEvents then
            warn("Maximum events reached, stopping parse")
            break
        end

        if command == 0x90 or command == 0x80 then
            local noteNumber = string.byte(buffer, offset)
            local velocity = string.byte(buffer, offset + 1)
            if not noteNumber or not velocity then break end
            offset = offset + 2

            local isOn = command == 0x90 and velocity > 0
            local key = tostring(noteNumber) .. ":" .. tostring(channel)

            if isOn then
                if noteOnStack[key] then
                    local prev = noteOnStack[key]
                    local lengthTicks = trackTime - prev.on_tick
                    if lengthTicks > 0 then
                        local onTime = CalculateRealtimePosition(prev.on_tick, ticksPerBeat, tempoChanges)
                        local offTime = CalculateRealtimePosition(trackTime, ticksPerBeat, tempoChanges)
                        table.insert(parsedEvents, {
                            type = 'on',
                            note = prev.note_name,
                            vel = prev.velocity,
                            channel = prev.channel,
                            abs_time = onTime,
                            tick = prev.on_tick
                        })
                        table.insert(parsedEvents, {
                            type = 'off',
                            note = prev.note_name,
                            channel = prev.channel,
                            abs_time = offTime,
                            tick = trackTime
                        })
                    end
                end
                noteOnStack[key] = {
                    on_tick = trackTime,
                    velocity = velocity,
                    note_name = noteNumber,
                    channel = channel
                }
            else
                local prev = noteOnStack[key]
                if prev then
                    local lengthTicks = trackTime - prev.on_tick
                    if lengthTicks > 0 then
                        local onTime = CalculateRealtimePosition(prev.on_tick, ticksPerBeat, tempoChanges)
                        local offTime = CalculateRealtimePosition(trackTime, ticksPerBeat, tempoChanges)
                        table.insert(parsedEvents, {
                            type = 'on',
                            note = prev.note_name,
                            vel = prev.velocity,
                            channel = prev.channel,
                            abs_time = onTime,
                            tick = prev.on_tick
                        })
                        table.insert(parsedEvents, {
                            type = 'off',
                            note = prev.note_name,
                            channel = prev.channel,
                            abs_time = offTime,
                            tick = trackTime
                        })
                    end
                    noteOnStack[key] = nil
                end
            end
        elseif command == 0xB0 then
            local controllerType = string.byte(buffer, offset)
            local value = string.byte(buffer, offset + 1)
            if not controllerType or not value then break end
            offset = offset + 2
            
            if controllerType == 64 then
                local controlTime = CalculateRealtimePosition(trackTime, ticksPerBeat, tempoChanges)
                table.insert(parsedEvents, {
                    type = 'control',
                    vel = value,
                    abs_time = controlTime,
                    tick = trackTime
                })
            end
        elseif status == 0xFF then
            local metaType = string.byte(buffer, offset)
            if not metaType then break end
            offset = offset + 1
            
            local length, lengthBytes = ReadVarInt(buffer, offset)
            offset = offset + lengthBytes
            
            if metaType == 0x51 and length == 3 then
                local b1, b2, b3 = string.byte(buffer, offset, offset + 2)
                if b1 and b2 and b3 then
                    local microPerBeat = b1 * 65536 + b2 * 256 + b3
                    if microPerBeat > 0 and microPerBeat < 60000000 then
                        table.insert(tempoChanges, {tick = trackTime, tempo = microPerBeat})
                    end
                end
            end
            offset = offset + length
        else
            local dataLen = (command == 0xC0 or command == 0xD0) and 1 or 2
            offset = offset + dataLen
        end

        if offset > trackEndOffset then
            offset = trackEndOffset + 1
        end
    end

    for key, prev in pairs(noteOnStack) do
        local onTime = CalculateRealtimePosition(prev.on_tick, ticksPerBeat, tempoChanges)
        table.insert(parsedEvents, {
            type = 'on',
            note = prev.note_name,
            vel = prev.velocity,
            channel = prev.channel,
            abs_time = onTime,
            tick = prev.on_tick
        })
    end

    if #parsedEvents == 0 then
        return nil, "No events found"
    end

    table.sort(parsedEvents, function(a, b) return a.abs_time < b.abs_time end)
    parsedEvents = ApplyDeblack(parsedEvents)
    
    return parsedEvents, tempoChanges
end

local function ReleaseAllKeys()
    for note, k in pairs(ActiveNotes) do
        _pcall(Vim.SendKeyEvent, Vim, false, k.keycode, false, game)
    end
    
    if Ctrl then 
        _pcall(Vim.SendKeyEvent, Vim, false, Enum.KeyCode.LeftControl, false, game)
        Ctrl = false 
    end
    if Shift then 
        _pcall(Vim.SendKeyEvent, Vim, false, Enum.KeyCode.LeftShift, false, game)
        Shift = false 
    end
    if Sustain then
        _pcall(Vim.SendKeyEvent, Vim, false, Enum.KeyCode.Space, false, game)
        Sustain = false
    end
    
    ActiveNotes = {}
end

local function GetCurrentPlaybackPosition()
    if Paused then
        return PausePosition
    else
        return (os.clock() - StartTime) * PlaybackSpeed
    end
end

local function PlayRealtimeEvents()
    if Paused or not Events or #Events == 0 then return end
    
    local elapsed = GetCurrentPlaybackPosition()
    local eventsProcessed = 0
    local maxEventsPerFrame = 100
    
    while NextEventIndex <= #Events and eventsProcessed < maxEventsPerFrame do
        local ev = Events[NextEventIndex]
        if not ev or not ev.abs_time then break end
        
        local eventTime = ev.abs_time
        
        if ev.type == "off" and RandomNoteEnabled then
            local randomOffset = (_math.random(0,15) * 0.01)
            eventTime = ev.abs_time - randomOffset
            if eventTime < 0 then eventTime = 0 end
        end
        if ev.type == "on" and RandomNoteEnabled then
            local randomOffset = _math.random(0, 5) * 0.01
            eventTime = ev.abs_time - randomOffset
            if eventTime < 0 then eventTime = 0 end
        end
        
        if eventTime <= elapsed then
            if ev.type == "on" then
                local k = KeyMap[ev.note]
                if k then
                    if not Key88Enabled and k.ctrl then
                        NextEventIndex = NextEventIndex + 1
                        eventsProcessed = eventsProcessed + 1
                        continue
                    end
                    
                    if k.ctrl and not Ctrl then 
                        _pcall(Vim.SendKeyEvent, Vim, true, Enum.KeyCode.LeftControl, false, game)
                        Ctrl = true 
                    elseif not k.ctrl and Ctrl then 
                        _pcall(Vim.SendKeyEvent, Vim, false, Enum.KeyCode.LeftControl, false, game)
                        Ctrl = false 
                    end
                    if k.shift and not Shift then 
                        _pcall(Vim.SendKeyEvent, Vim, true, Enum.KeyCode.LeftShift, false, game)
                        Shift = true 
                    elseif not k.shift and Shift then 
                        _pcall(Vim.SendKeyEvent, Vim, false, Enum.KeyCode.LeftShift, false, game)
                        Shift = false 
                    end
                    
                    _pcall(Vim.SendKeyEvent, Vim, true, k.keycode, false, game)
                    ActiveNotes[ev.note] = k

                    if NoNoteOffEnabled then
                        _pcall(Vim.SendKeyEvent, Vim, false, k.keycode, false, game)
                        ActiveNotes[ev.note] = nil
                    end
                end
            elseif ev.type == "off" then
                if not NoNoteOffEnabled then
                    local k = ActiveNotes[ev.note]
                    if k then
                        _pcall(Vim.SendKeyEvent, Vim, false, k.keycode, false, game)
                        ActiveNotes[ev.note] = nil
                    end
                end
            elseif ev.type == "control" then
                local s = ev.vel >= 64
                if AutoSustainEnabled then
                    if s ~= Sustain then 
                        _pcall(Vim.SendKeyEvent, Vim, s, Enum.KeyCode.Space, false, game)
                        Sustain = s 
                    end
                else
                    if not Sustain then 
                        _pcall(Vim.SendKeyEvent, Vim, true, Enum.KeyCode.Space, false, game)
                        Sustain = true 
                    end
                end
            end
            NextEventIndex = NextEventIndex + 1
            eventsProcessed = eventsProcessed + 1
        else
            break
        end
    end

    if NextEventIndex > #Events then
        Paused = true
        StartTime = 0
        NextEventIndex = 1
        PausePosition = 0
        ReleaseAllKeys()
    end
end

local function StartPlayback(parsedEvents, tempoChanges)
    if not parsedEvents or #parsedEvents == 0 then return end
    
    Events = parsedEvents
    TempoEvents = tempoChanges or {}
    TotalDuration = Events[#Events] and Events[#Events].abs_time or 0
    StartTime = os.clock()
    NextEventIndex = 1
    PausePosition = 0
    ReleaseAllKeys()
    Paused = false
    MidiLoaded = true
end

local function PausePlayback()
    if not Paused then
        Paused = true
        PausePosition = (os.clock() - StartTime) * PlaybackSpeed
        ReleaseAllKeys()
    end
end

local function ResumePlayback()
    if Paused and MidiLoaded then
        StartTime = os.clock() - (PausePosition / PlaybackSpeed)
        Paused = false
    end
end

local function StopPlayback()
    Paused = true
    StartTime = 0
    NextEventIndex = 1
    PausePosition = 0
    ReleaseAllKeys()
end

local function SeekToPosition(ratio)
    if not MidiLoaded or TotalDuration == 0 then return end
    
    local targetTime = TotalDuration * _math.clamp(ratio, 0, 1)
    PausePosition = targetTime
    
    NextEventIndex = 1
    for i = 1, #Events do
        if Events[i].abs_time > targetTime then
            NextEventIndex = i
            break
        end
    end
    
    if not Paused then
        StartTime = os.clock() - (targetTime / PlaybackSpeed)
    end
    
    ReleaseAllKeys()
end

local function ListMidiFiles()
    MidiFiles = {}
    local ok, files = _pcall(listfiles, "./MIDI")
    if ok and files then
        for _, f in ipairs(files) do
            if f:match("%.mid$") or f:match("%.midi$") then
                local name = f:match("[^/\\]+$")
                if name then
                    table.insert(MidiFiles, name)
                end
            end
        end
    end
end

local function LoadMidiFromData(data, uiSetter)
    if IsLoading then return end
    if not data or #data == 0 then
        uiSetter("‚ùå Empty file")
        return
    end
    
    IsLoading = true
    uiSetter("‚è≥ Parsing MIDI...")

    _task.spawn(function()
        Events = {}
        TempoEvents = {}
        
        local ok, parsed, tempochg = _pcall(ParseMidiImproved, data)
        
        if not ok then
            uiSetter("‚ùå Parse error: " .. tostring(parsed))
            IsLoading = false
            return
        end
        
        if not parsed then
            uiSetter("‚ùå Invalid MIDI: " .. tostring(tempochg or "unknown error"))
            IsLoading = false
            return
        end

        Events = parsed
        TempoEvents = tempochg or {}
        TotalDuration = Events[#Events] and Events[#Events].abs_time or 0
        NextEventIndex = 1
        PausePosition = 0
        Paused = true
        MidiLoaded = true
        IsLoading = false
        
        if PlayedSliderRef and TotalDuration > 0 then
            _pcall(PlayedSliderRef.SetMin, PlayedSliderRef, 0)
            _pcall(PlayedSliderRef.SetMax, PlayedSliderRef, TotalDuration)
        end
        
        local eventCount = #Events
        local durationStr = string.format("%.2f", TotalDuration)
        local sizeKb = string.format("%.1f", #data / 1024)
        uiSetter("‚úÖ " .. eventCount .. " events, " .. durationStr .. "s (" .. sizeKb .. "KB)")
    end)
end

run(function()
    if not WindUI then return end
    
    local Anonymous = false
    local Window = WindUI:CreateWindow({
        Title = "MIDI Player",
        Author = "made with love",
        Size = UDim2.fromOffset(600, 260),
        SideBarWidth = 150,
        Folder = "AntiLua",
        NewElements = true,
        HideSearchBar = true,
        User = {
            Enabled = true,
            Anonymous = false,
            Callback = function()
                Anonymous = not Anonymous
                Window:SetAnonymous(Anonymous)
            end,
        },
    })

    Window:OnDestroy(function()
        shared.AntiLuaLoading = false
        StopPlayback()
        ReleaseAllKeys()
        
        if CleanupConnection then
            CleanupConnection:Disconnect()
            CleanupConnection = nil
        end
        
        Events = {}
        TempoEvents = {}
        MidiLoaded = false
        IsLoading = false
    end)

    local MainTab = Window:Tab({ Title = "Main", Icon = "house", })
    local SettingsTab = Window:Tab({ Title = "Settings", Icon = "settings", })

    local StatusLabel = MainTab:Paragraph({ Title = "Status", Desc = "Ready" })

    ListMidiFiles()
    local fileVals = {}
    for _, f in ipairs(MidiFiles) do table.insert(fileVals, f) end

    local SelectedFile = nil
    local UrlInputValue = ""
    
    local UrlInput = MainTab:Input({
        Title = "URL or Filename",
        Placeholder = "https:// or filename.mid",
        Callback = function(val)
            UrlInputValue = val
        end
    })

    local FileDropdown = MainTab:Dropdown({
        Title = "MIDI Files",
        Desc = "Choose from ./MIDI",
        Values = fileVals,
        Value = MidiFiles[1] or nil,
        Callback = function(option)
            SelectedFile = option
            UrlInput:Set(option)
            StatusLabel:SetDesc("Selected: " .. option)
        end
    })

    MainTab:Button({
        Title = "Load",
        Callback = function()
            if IsLoading then 
                StatusLabel:SetDesc("‚è≥ Already loading...")
                WindUI:Notify({
                    Title = "MIDI Player",
                    Content = "Already loading, please wait...",
                    Duration = 3,
                    Icon = "bird",
                })
                return 
            end
            
            local loadSource = nil
            local txt = UrlInputValue or ""
            
            if txt ~= "" then
                loadSource = "url"
            elseif SelectedFile then
                txt = SelectedFile
                loadSource = "file"
            else
                StatusLabel:SetDesc("‚ùå No file selected or URL entered")
                WindUI:Notify({
                    Title = "MIDI Player",
                    Content = "No file selected or URL entered",
                    Duration = 3,
                    Icon = "bird",
                })
                return
            end
            
            if loadSource == "url" and string.match(txt, "^https?://") then
                StatusLabel:SetDesc("‚è≥ Downloading...")
                _task.spawn(function()
                    local ok, body = _pcall(game.HttpGet, game, txt)
                    if ok and body and #body > 0 then
                        LoadMidiFromData(body, function(txt) 
                            StatusLabel:SetDesc(txt)
                            WindUI:Notify({
                                Title = "MIDI Player",
                                Content = txt,
                                Duration = 10,
                                Icon = "bird",
                            })
                        end)
                    else
                        StatusLabel:SetDesc("‚ùå Download failed or empty file")
                        WindUI:Notify({
                            Title = "MIDI Player",
                            Content = "Download failed or empty file",
                            Duration = 5,
                            Icon = "bird",
                        })
                        IsLoading = false
                    end
                end)
            else
                local filePath = "./MIDI/" .. txt
                if not isfile(filePath) then
                    StatusLabel:SetDesc("‚ùå File not found: " .. txt)
                    WindUI:Notify({
                        Title = "MIDI Player",
                        Content = "File not found: " .. txt,
                        Duration = 5,
                        Icon = "bird",
                    })
                    return
                end
                
                local ok, data = _pcall(readfile, filePath)
                if ok and data and #data > 0 then
                    StatusLabel:SetDesc("‚è≥ Loading file...")
                    LoadMidiFromData(data, function(txt) 
                        StatusLabel:SetDesc(txt) 
                        WindUI:Notify({
                            Title = "MIDI Player",
                            Content = txt,
                            Duration = 10,
                            Icon = "bird",
                        })
                    end)
                else
                    StatusLabel:SetDesc("‚ùå Failed to read file: " .. txt)
                    WindUI:Notify({
                        Title = "MIDI Player",
                        Content = "Failed to read file: " .. txt,
                        Duration = 5,
                        Icon = "bird",
                    })
                end
            end
        end
    })

    MainTab:Button({
        Title = "Refresh File List",
        Callback = function()
            ListMidiFiles()
            local vals = {}
            for _, f in ipairs(MidiFiles) do table.insert(vals, f) end
            FileDropdown:Refresh(vals)
            StatusLabel:SetDesc("üîÑ Found " .. #MidiFiles .. " files")
            WindUI:Notify({
                Title = "MIDI Player",
                Content = "Found " .. #MidiFiles .. " MIDI files",
                Duration = 3,
                Icon = "bird",
            })
        end
    })

    MainTab:Button({
        Title = "Play",
        Callback = function()
            if not MidiLoaded then 
                StatusLabel:SetDesc("‚ùå No MIDI loaded")
                WindUI:Notify({
                    Title = "MIDI Player",
                    Content = "Please load a MIDI file first",
                    Duration = 3,
                    Icon = "bird",
                })
                return 
            end
            if Paused and PausePosition > 0 then
                ResumePlayback()
                StatusLabel:SetDesc("‚ñ∂Ô∏è Resumed")
            elseif Paused and PausePosition == 0 then
                StartPlayback(Events, TempoEvents)
                StatusLabel:SetDesc("‚ñ∂Ô∏è Playing")
            else
                StatusLabel:SetDesc("‚ÑπÔ∏è Already playing")
            end
        end
    })

    MainTab:Button({
        Title = "Pause",
        Callback = function()
            if not MidiLoaded then return end
            if Paused then
                ResumePlayback()
                StatusLabel:SetDesc("‚ñ∂Ô∏è Resumed")
            else
                PausePlayback()
                StatusLabel:SetDesc("‚è∏Ô∏è Paused")
            end
        end
    })

    MainTab:Button({
        Title = "Stop",
        Callback = function() 
            StopPlayback()
            StatusLabel:SetDesc("‚èπÔ∏è Stopped")
        end
    })

    local LastPlayedChange = 0
    local WasPlayingBeforePlayed = false

    PlayedSliderRef = MainTab:Slider({
        Title = "Played Time (s)",
        Step = 0.01,
        Value = { Min = 0, Max = 1, Default = 0 },
        Callback = function(v)
            if IgnorePlayedSliderCallback then return end
            if not MidiLoaded or TotalDuration == 0 then return end

            if not Paused and not WasPlayingBeforePlayed then
                WasPlayingBeforePlayed = true
                PausePlayback()
            end

            LastPlayedChange = os.clock()
            local sec = _math.clamp(v, 0, TotalDuration)
            if TotalDuration > 0 then
                local ratio = sec / TotalDuration
                SeekToPosition(ratio)
                StatusLabel:SetDesc("‚è© " .. string.format("%.2f", sec) .. "s / " .. string.format("%.2f", TotalDuration) .. "s")
            end

            _task.spawn(function()
                _task.wait(DebounceTime)
                if os.clock() - LastPlayedChange >= DebounceTime then
                    if WasPlayingBeforePlayed then
                        ResumePlayback()
                        WasPlayingBeforePlayed = false
                    end
                end
            end)
        end
    })

    local LastSpeedChange = 0
    local WasPlayingBeforeSpeed = false
    local SpeedSliderRef

    SpeedSliderRef = MainTab:Slider({
        Title = "Playback Speed (%)",
        Step = 1,
        Value = { Min = 50, Max = 200, Default = _math.floor(PlaybackSpeed * 100) },
        Callback = function(v)
            if IgnoreSpeedSliderCallback then return end
            
            if not Paused and not WasPlayingBeforeSpeed then
                WasPlayingBeforeSpeed = true
                PausePlayback()
            end

            LastSpeedChange = os.clock()
            local oldpos = GetCurrentPlaybackPosition()
            PlaybackSpeed = _math.clamp(v / 100, 0.5, 2.0)
            PausePosition = oldpos

            _task.spawn(function()
                _task.wait(DebounceTime)
                if os.clock() - LastSpeedChange >= DebounceTime then
                    if WasPlayingBeforeSpeed then
                        ResumePlayback()
                        WasPlayingBeforeSpeed = false
                    end
                end
            end)
        end
    })

    SettingsTab:Toggle({
        Title = "DeBlack Filter",
        Desc = "Remove ultra-short notes (recommended for large files)",
        Value = DeblackEnabled,
        Callback = function(v) 
            DeblackEnabled = v
            WindUI:Notify({
                Title = "MIDI Player",
                Content = (DeblackEnabled and "üîß DeBlack ON" or "üîß DeBlack OFF"),
                Duration = 3,
                Icon = "bird",
            })
        end
    })

    SettingsTab:Slider({
        Title = "DeBlack Velocity Level",
        Step = 1,
        Value = { Min = 0, Max = 127, Default = DeblackLevel },
        Callback = function(v) 
            DeblackLevel = _math.clamp(_math.floor(v), 0, 127)
        end
    })

    SettingsTab:Toggle({
        Title = "Auto Sustain Pedal",
        Desc = "Automatically handle sustain events",
        Value = AutoSustainEnabled,
        Callback = function(v) 
            AutoSustainEnabled = v
            WindUI:Notify({
                Title = "MIDI Player",
                Content = (AutoSustainEnabled and "üîß Auto Sustain ON" or "üîß Auto Sustain OFF"),
                Duration = 3,
                Icon = "bird",
            })
        end
    })

    SettingsTab:Toggle({
        Title = "88 Key Mode",
        Desc = "Enable full 88-key keyboard (uses Ctrl keys)",
        Value = Key88Enabled,
        Callback = function(v) 
            Key88Enabled = v
            WindUI:Notify({
                Title = "MIDI Player",
                Content = (Key88Enabled and "üéπ 88 Key ON" or "üéπ 88 Key OFF"),
                Duration = 3,
                Icon = "bird",
            })
        end
    })

    SettingsTab:Toggle({
        Title = "Force Note-Off",
        Desc = "Instantly release notes (may sound choppy)",
        Value = NoNoteOffEnabled,
        Callback = function(v) 
            NoNoteOffEnabled = v
            if v then ReleaseAllKeys() end
            WindUI:Notify({
                Title = "MIDI Player",
                Content = (NoNoteOffEnabled and "üîß Force Note-Off ON" or "üîß Force Note-Off OFF"),
                Duration = 3,
                Icon = "bird",
            })
        end
    })

    SettingsTab:Toggle({
        Title = "Human Player Mode",
        Desc = "Add slight random timing variations",
        Value = RandomNoteEnabled,
        Callback = function(v) 
            RandomNoteEnabled = v
            WindUI:Notify({
                Title = "MIDI Player",
                Content = (RandomNoteEnabled and "üéµ Human Mode ON" or "üéµ Human Mode OFF"),
                Duration = 3,
                Icon = "bird",
            })
        end
    })

    if RunService and RunService.RenderStepped then
        CleanupConnection = RunService.RenderStepped:Connect(function()
            _pcall(function()
                PlayRealtimeEvents()

                if MidiLoaded and TotalDuration and TotalDuration > 0 then
                    local elapsed = GetCurrentPlaybackPosition()
                    if PlayedSliderRef then
                        IgnorePlayedSliderCallback = true
                        _pcall(PlayedSliderRef.Set, PlayedSliderRef, tonumber(elapsed) or 0)
                        IgnorePlayedSliderCallback = false
                    end
                end
                
                if SpeedSliderRef then
                    local currentSpeed = _math.floor(PlaybackSpeed * 100)
                    IgnoreSpeedSliderCallback = true
                    _pcall(SpeedSliderRef.Set, SpeedSliderRef, currentSpeed)
                    IgnoreSpeedSliderCallback = false
                end
            end)
        end)
    end

    Window:SetToggleKey(Enum.KeyCode.RightControl)
    Window:ToggleTransparency(true)
    Window:SelectTab(1)
    StatusLabel:SetDesc("‚úÖ Ready - Load a MIDI file to begin")
    
    WindUI:Notify({
        Title = "MIDI Player",
        Content = "Loaded successfully! Right Ctrl to toggle UI",
        Duration = 5,
        Icon = "bird",
    })
end)

run(function()
    if not getgenv().Bypassed then
        getgenv().Bypassed = true
        local ok, knit = _pcall(function() 
            return require(Services.ReplicatedStorage.Packages.Knit) 
        end)
        if ok and knit then
            knit.OnStart():catch(warn):andThen(function()
                local detectionService = knit.GetService("DetectionService")
                if detectionService and detectionService.WindowFocused then
                    _task.spawn(function()
                        while _task.wait(1) do
                            _pcall(detectionService.WindowFocused.Fire, detectionService.WindowFocused, true)
                        end
                    end)
                end
            end)
            if WindUI then
                WindUI:Notify({
                    Title = "MIDI Player",
                    Content = "üõ°Ô∏è Anti-AFK Active",
                    Duration = 3,
                    Icon = "bird",
                })
            end
        end
    end
end)